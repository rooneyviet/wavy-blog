{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Docker Environment Setup for Backend and LocalStack",
        "description": "Create the Docker environment for the Go backend and LocalStack. This includes the Dockerfile for the Go application and a docker-compose file to orchestrate the services.",
        "details": "In the project root, update `docker-compose.dev.yml` to define two services: `api-backend` and `localstack`. The `api-backend` service should build from `backend/Dockerfile.dev` and mount the `backend` directory for live reloading. It should also use `.env.dev` for environment variables. The `localstack` service should use the `localstack/localstack` image and expose the necessary ports for DynamoDB (4566). Create `backend/Dockerfile.dev` using a multi-stage build: a `builder` stage with `golang:1.21-alpine` to build the app and a final stage using `alpine` to run the binary. Create `backend/.env.dev` with variables like `AWS_REGION`, `AWS_ENDPOINT` (pointing to `http://localstack:4566`), `DYNAMODB_TABLE_NAME=WavyBlog`.",
        "testStrategy": "Run `docker compose -f docker-compose.dev.yml up --build`. Verify that both `api-backend` and `localstack` containers start without errors. Check the logs to ensure the services are running. Use the AWS CLI (can be run from another container or host if installed) to list tables against the LocalStack endpoint to confirm it's operational: `aws --endpoint-url=http://localhost:4566 dynamodb list-tables`.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Backend Scaffolding and Go Module Initialization",
        "description": "Create the backend project directory structure and initialize the Go module. This task sets up the skeleton of the application as per the PRD.",
        "details": "Inside the root of the project, create the `backend` directory. Within `backend`, create the specified folder structure: `cmd/api`, `internal/api/handlers`, `internal/api`, `internal/config`, `internal/domain`, `internal/repository/dynamodb`. Create empty placeholder files: `main.go`, `posts.go`, `users.go`, `router.go`, `config.go`, `post.go`, `user.go`, `dbrepo.go`, `repository.go`. Use the running `api-backend` container to initialize the Go module: `docker compose -f docker-compose.dev.yml exec api-backend go mod init wavy.blog/backend`. Then, add the Gin and AWS SDK dependencies: `docker compose exec api-backend go get github.com/gin-gonic/gin` and `docker compose exec api-backend go get github.com/aws/aws-sdk-go-v2/config github.com/aws/aws-sdk-go-v2/service/dynamodb`.",
        "testStrategy": "Verify that the directory structure and all files are created correctly. Check the `go.mod` and `go.sum` files to ensure they have been created and contain the specified dependencies. The application should still build and run successfully via Docker Compose, even with just a basic `main` function.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Define Domain Models and Configuration Management",
        "description": "Define the core domain models (User, Post) and implement the configuration loading logic for the application.",
        "details": "In `internal/domain/user.go`, define the `User` struct with fields `UserID`, `Username`, `Email`, `PasswordHash`, `CreatedAt`, `UpdatedAt`. Use `json` and `dynamodbav` tags for marshalling. In `internal/domain/post.go`, define the `Post` struct with fields `PostID`, `Title`, `Content`, `AuthorID`, `Category`, `ThumbnailURL`, `CreatedAt`, `UpdatedAt`. In `internal/config/config.go`, create a `Config` struct and a `LoadConfig` function that reads environment variables from `.env.dev` (e.g., using a library like `godotenv` and `os.Getenv`) to populate the struct. The `main.go` file should call `LoadConfig` on startup.",
        "testStrategy": "Write unit tests for the `LoadConfig` function to ensure it correctly reads and parses environment variables. For domain models, ensure the project compiles successfully after defining the structs. No runtime tests are needed for the models themselves.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement DynamoDB Repository Layer",
        "description": "Define the repository interface and implement it for DynamoDB, including table creation logic and connection to LocalStack.",
        "details": "In `internal/repository/repository.go`, define a `DatabaseRepo` interface with methods for user and post operations (e.g., `CreateUser`, `GetUserByEmail`, `CreatePost`, `GetPostByID`, `GetPostsByUser`, etc.). In `internal/repository/dynamodb/dbrepo.go`, create a `DynamoDBRepo` struct that holds the DynamoDB client. Implement the `DatabaseRepo` interface. The implementation will use the AWS SDK for Go v2. The functions will construct `PutItem`, `GetItem`, `Query`, and `Scan` inputs based on the single-table design schema (e.g., for `CreateUser`, create two items: one with PK `USER#<UserID>` and SK `METADATA#<UserID>`, and for `CreatePost`, create items for the post itself, the user-post link, and the category-post link). Add a utility function `CreateTableIfNotExists` that is called on application startup to create the `WavyBlog` table in LocalStack with the specified PK and SK.",
        "testStrategy": "Write integration tests for the repository implementation. The tests should run against the LocalStack container. Each function in the repository (e.g., `CreateUser`, `GetPostByID`) should have a corresponding test that writes data to DynamoDB and then reads it back to verify correctness. Use the AWS CLI to manually inspect the `WavyBlog` table in LocalStack to confirm the single-table design patterns are being written correctly.",
        "priority": "high",
        "dependencies": [
          1,
          3
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement API Router and User Management Endpoints",
        "description": "Set up the Gin router and implement the HTTP handlers for all User Management API endpoints.",
        "details": "In `internal/api/router.go`, create a `SetupRouter` function that initializes a new Gin engine. It should take the `DatabaseRepo` as a dependency. Create a `/api` route group. In `internal/api/handlers/users.go`, create handlers for `POST /users/register`, `POST /users/login`, `GET /users`, and `GET /users/:id`. The `register` handler will hash the password (using `bcrypt`) before calling the repository. The `login` handler will verify credentials and generate a JWT token (using a library like `golang-jwt/jwt/v5`). The `main.go` file will initialize the repository, pass it to the router, and start the HTTP server.",
        "testStrategy": "Use an API client like Postman or Insomnia to test the endpoints. 1. Send a POST request to `/api/users/register` with user data and verify a 201 response. 2. Use the new credentials to POST to `/api/users/login` and verify a JWT is returned. 3. Attempt to access protected endpoints (e.g., `GET /users`) without and with the token to test authentication middleware. 4. Check the DynamoDB table via AWS CLI to confirm the user record was created correctly.",
        "priority": "medium",
        "dependencies": [
          2,
          4
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Post Management API Endpoints",
        "description": "Implement the HTTP handlers for all Post Management API endpoints, including CRUD operations.",
        "details": "In `internal/api/handlers/posts.go`, create handlers for `POST /posts`, `GET /posts`, `GET /posts/:id`, `PUT /posts/:id`, and `DELETE /posts/:id`. These handlers will receive the request, validate the input (and JWT for protected routes), call the appropriate methods on the `DatabaseRepo` interface, and return the response. The `POST /posts` handler will create multiple items in DynamoDB as per the single-table design (Post, PostByUser, PostByCategory). The `GET /posts` handler should support pagination using query parameters and perform a Scan or Query operation. The router in `router.go` should be updated to map these handlers to their respective routes.",
        "testStrategy": "Using an API client: 1. Register and log in a user to get a JWT. 2. Use the token to send a POST request to `/api/posts` to create a new post. 3. Send a GET request to `/api/posts` to verify the new post is in the list. 4. Send a GET request to `/api/posts/:id` to fetch the specific post. 5. Send PUT and DELETE requests to test update and delete functionality. Verify changes in the DynamoDB table.",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Category Endpoint and Finalize API",
        "description": "Implement the final API endpoint for retrieving unique post categories and perform final integration checks.",
        "details": "In `internal/repository/dynamodb/dbrepo.go`, add a `GetUniqueCategories` method. This method will perform a DynamoDB query targeting items with a PK prefix of `CATEGORY#`. It will need to process the results to return a list of unique category names. In `internal/api/handlers/posts.go` (or a new `categories.go`), create a handler for `GET /categories`. This handler will call the new repository method and return the list of unique categories as a JSON array. Update the router in `router.go` to include this new endpoint. This task also includes a final review of all code, adding logging middleware, and ensuring consistent error handling across all endpoints.",
        "testStrategy": "1. Create several posts with a mix of new and existing categories using the `/api/posts` endpoint. 2. Send a GET request to `/api/categories`. 3. Verify that the response is a JSON array of strings, containing each unique category name exactly once. 4. Manually query the DynamoDB table for `PK` starting with `CATEGORY#` to cross-reference the results and ensure correctness.",
        "priority": "low",
        "dependencies": [
          6
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement JWT Authentication and Middleware",
        "description": "Implement JWT generation for the login handler and create a middleware to protect post creation, update, and deletion endpoints, securing write operations for the application.",
        "details": "In `internal/api/handlers/users.go`, update the `LoginUser` handler. After successfully validating credentials, it should generate a signed JWT using a library like `github.com/golang-jwt/jwt/v5`. The JWT claims must include the `UserID` and an expiration time. The JWT secret key should be loaded from the application's configuration. Create a new package `internal/api/middleware` with an `AuthMiddleware()` function. This middleware will extract the token from the 'Authorization: Bearer <token>' header, validate its signature and expiration, and extract the `UserID` from its claims. The extracted `UserID` should be set in the Gin context for use by subsequent handlers. If the token is missing or invalid, the middleware must abort the request with a 401 Unauthorized status. In `internal/api/router.go`, apply this new middleware to a route group that includes the protected routes: `POST /posts`, `PUT /posts/:id`, and `DELETE /posts/:id`.",
        "testStrategy": "1. Attempt to access a protected endpoint, e.g., `POST /api/posts`, without an Authorization header. Verify the response is `401 Unauthorized`. 2. Attempt to access the same endpoint with an invalid or expired JWT. Verify the response is `401 Unauthorized`. 3. Send a `POST` request to `/api/users/login` with valid credentials. Verify the response is `200 OK` and contains a JWT in the response body. 4. Using the token from the successful login, send a `POST` request to `/api/posts` with the header `Authorization: Bearer <jwt>`. Verify the request succeeds with a `201 Created` status. 5. Confirm that public routes like `GET /api/posts` remain accessible without any token.",
        "status": "done",
        "dependencies": [
          5,
          6
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Update and Delete User API Endpoints",
        "description": "Implement the API endpoints for updating and deleting user profiles. This includes creating the repository methods and HTTP handlers, ensuring the endpoints are protected by JWT authentication.",
        "details": "This task involves extending the user management functionality. First, in `internal/repository/repository.go`, add `UpdateUser(ctx context.Context, user models.User) error` and `DeleteUser(ctx context.Context, userID string) error` to the `DatabaseRepo` interface. Then, implement these methods in `internal/repository/dynamodb/dbrepo.go`. The `UpdateUser` method should use a DynamoDB `UpdateItem` operation to modify user attributes, disallowing changes to `UserID` and `Email`, and automatically updating the `UpdatedAt` timestamp. The `DeleteUser` method will use `DeleteItem` to remove the user's primary record. In `internal/api/handlers/users.go`, create `UpdateUser` and `DeleteUser` handlers. These handlers must extract the user ID from the JWT claims (added by the auth middleware) and compare it against the user ID from the URL path (`:id`) to ensure a user can only modify or delete their own account. Finally, register the new `PUT /users/:id` and `DELETE /users/:id` routes in `internal/api/router.go` within the route group protected by the `AuthMiddleware`.",
        "testStrategy": "1. Register two users, User A and User B, and log them in to obtain their respective JWTs. 2. Using User A's JWT, send a `PUT` request to `/api/users/{user_a_id}` with updated data (e.g., new username). Verify a `200 OK` response with the updated user object. 3. Using User B's JWT, attempt to send a `PUT` request to `/api/users/{user_a_id}`. Verify the response is `403 Forbidden`. 4. Attempt to send a `PUT` request to `/api/users/{user_a_id}` without any JWT. Verify the response is `401 Unauthorized`. 5. Using User A's JWT, send a `DELETE` request to `/api/users/{user_a_id}`. Verify a `204 No Content` response. 6. Attempt to log in as User A and verify it fails, confirming deletion.",
        "status": "done",
        "dependencies": [
          4,
          5,
          8
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Update and Delete Post API Endpoints",
        "description": "Implement the API endpoints for updating and deleting posts. This includes creating the repository methods and HTTP handlers, ensuring the endpoints are protected by JWT authentication.",
        "details": "First, extend the `DatabaseRepo` interface in `internal/repository/repository.go` with `UpdatePost(ctx context.Context, post models.Post) error` and `DeletePost(ctx context.Context, postID, authorID string) error`. Implement these methods in `internal/repository/dynamodb/dbrepo.go`. The `UpdatePost` method should use a DynamoDB `UpdateItem` operation to modify the main post item (PK: `POST#{postID}`). It must also update the denormalized data in the `PostByUser` item (PK: `USER#{authorID}`, SK: `POST#{postID}`). The `DeletePost` method must perform a transactional write (`TransactWriteItems`) to atomically delete the three related items: the main `Post` item, the `PostByUser` item, and the `PostByCategory` item. In `internal/api/handlers/posts.go`, create `UpdatePost` and `DeletePost` handlers. These handlers must extract the `UserID` from the JWT context, fetch the post by its ID to verify the `AuthorID` matches the user's ID, and then call the appropriate repository method. Finally, register the new `PUT /api/posts/:id` and `DELETE /api/posts/:id` routes in `router.go` within the route group protected by the `AuthMiddleware`.",
        "testStrategy": "1. Register and log in two separate users (User A and User B) to obtain their JWTs. 2. Using User A's JWT, create a new post. 3. Using User A's JWT, send a `PUT` request to `/api/posts/{post_id}` with updated title and content. Verify a `200 OK` response and that a subsequent `GET` request for the post returns the updated data. 4. Using User B's JWT, attempt to send a `PUT` request to the same post ID. Verify the response is `403 Forbidden`. 5. Using User B's JWT, attempt to send a `DELETE` request for the post. Verify the response is `403 Forbidden`. 6. Using User A's JWT, send a `DELETE` request for the post. Verify a `204 No Content` response. 7. Attempt to `GET` the post by its ID and verify a `404 Not Found` response.",
        "status": "done",
        "dependencies": [
          6,
          8
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Create Bruno Project for API Testing",
        "description": "Create a Bruno project to automate API testing. This includes setting up collections and requests for user registration, login, and post creation, with scripting to handle JWT authentication.",
        "details": "In the project root, create a new directory named `bruno-tests`. Inside this directory, initialize a new Bruno collection. Create a 'local' environment to store variables, starting with `baseUrl` set to `http://localhost:8080/api`. Configure three requests within the collection:\n1. **Register User**: A `POST` request to `{{baseUrl}}/users/register` with a JSON body containing `username`, `email`, and `password`.\n2. **Login User**: A `POST` request to `{{baseUrl}}/users/login` with the same `email` and `password`. In the 'Tests' tab of this request, add a script to parse the response body, extract the `access_token`, and set it as a collection variable named `authToken` using `bru.setVar('authToken', res.body.access_token);`.\n3. **Create Post**: A `POST` request to `{{baseUrl}}/posts`. In the 'Auth' tab, select 'Bearer Token' and use the `{{authToken}}` variable. The request body should be JSON with `title`, `content`, and `category` fields.",
        "testStrategy": "1. Run the 'Register User' request and verify a `201 Created` response.\n2. Run the 'Login User' request. Verify a `200 OK` response and inspect the Bruno collection variables to confirm that `authToken` has been set with a valid JWT.\n3. Run the 'Create Post' request. Verify it succeeds with a `201 Created` response, which confirms the bearer token was correctly extracted and used for authentication.\n4. Ensure the entire `bruno-tests` directory and its contents are committed to the repository.",
        "status": "done",
        "dependencies": [
          5,
          6,
          8
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Fix 404 Error in Bruno Login Request by Correcting Port",
        "description": "Correct the port number in the Bruno 'local' environment configuration to resolve the 404 Not Found error when executing the login API request. The port must match the one exposed by the backend service in the Docker environment.",
        "details": "The 'Login User' request in the Bruno collection is failing with a 404 error because the `baseUrl` variable in the 'local' environment points to the wrong port. Locate the Bruno environment configuration file (likely within the `bruno-tests` directory). Inspect the `docker-compose.dev.yml` file to find the host port mapped to the `api-backend` service's container port (e.g., '8090:8080'). Update the `baseUrl` variable in the Bruno 'local' environment to use the correct host port. For example, change `http://localhost:8080/api` to `http://localhost:8090/api` if the host port is 8090.",
        "testStrategy": "1. Ensure the backend application is running via `docker compose -f docker-compose.dev.yml up`. 2. Open the API collection in Bruno. 3. Run the 'Register User' request to ensure a test user exists. 4. Run the 'Login User' request using the same credentials. 5. Verify that the request now succeeds with a `200 OK` status code, resolving the previous `404 Not Found` error. 6. Check the collection variables to confirm that the `authToken` has been successfully extracted and stored from the response.",
        "status": "done",
        "dependencies": [
          1,
          5,
          11
        ],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-07T12:12:29.200Z",
      "updated": "2025-07-09T01:06:24.604Z",
      "description": "Tasks for master context"
    }
  },
  "feature-ssr-data-connection": {
    "tasks": [
      {
        "id": 1,
        "title": "Docker Environment Setup for Backend and LocalStack",
        "description": "Create the Docker environment for the Go backend and LocalStack. This includes the Dockerfile for the Go application and a docker-compose file to orchestrate the services.",
        "details": "In the project root, update `docker-compose.dev.yml` to define two services: `api-backend` and `localstack`. The `api-backend` service should build from `backend/Dockerfile.dev` and mount the `backend` directory for live reloading. It should also use `.env.dev` for environment variables. The `localstack` service should use the `localstack/localstack` image and expose the necessary ports for DynamoDB (4566). Create `backend/Dockerfile.dev` using a multi-stage build: a `builder` stage with `golang:1.21-alpine` to build the app and a final stage using `alpine` to run the binary. Create `backend/.env.dev` with variables like `AWS_REGION`, `AWS_ENDPOINT` (pointing to `http://localstack:4566`), `DYNAMODB_TABLE_NAME=WavyBlog`.",
        "testStrategy": "Run `docker compose -f docker-compose.dev.yml up --build`. Verify that both `api-backend` and `localstack` containers start without errors. Check the logs to ensure the services are running. Use the AWS CLI (can be run from another container or host if installed) to list tables against the LocalStack endpoint to confirm it's operational: `aws --endpoint-url=http://localhost:4566 dynamodb list-tables`.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Backend Scaffolding and Go Module Initialization",
        "description": "Create the backend project directory structure and initialize the Go module. This task sets up the skeleton of the application as per the PRD.",
        "details": "Inside the root of the project, create the `backend` directory. Within `backend`, create the specified folder structure: `cmd/api`, `internal/api/handlers`, `internal/api`, `internal/config`, `internal/domain`, `internal/repository/dynamodb`. Create empty placeholder files: `main.go`, `posts.go`, `users.go`, `router.go`, `config.go`, `post.go`, `user.go`, `dbrepo.go`, `repository.go`. Use the running `api-backend` container to initialize the Go module: `docker compose -f docker-compose.dev.yml exec api-backend go mod init wavy.blog/backend`. Then, add the Gin and AWS SDK dependencies: `docker compose exec api-backend go get github.com/gin-gonic/gin` and `docker compose exec api-backend go get github.com/aws/aws-sdk-go-v2/config github.com/aws/aws-sdk-go-v2/service/dynamodb`.",
        "testStrategy": "Verify that the directory structure and all files are created correctly. Check the `go.mod` and `go.sum` files to ensure they have been created and contain the specified dependencies. The application should still build and run successfully via Docker Compose, even with just a basic `main` function.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Define Domain Models and Configuration Management",
        "description": "Define the core domain models (User, Post) and implement the configuration loading logic for the application.",
        "details": "In `internal/domain/user.go`, define the `User` struct with fields `UserID`, `Username`, `Email`, `PasswordHash`, `CreatedAt`, `UpdatedAt`. Use `json` and `dynamodbav` tags for marshalling. In `internal/domain/post.go`, define the `Post` struct with fields `PostID`, `Title`, `Content`, `AuthorID`, `Category`, `ThumbnailURL`, `CreatedAt`, `UpdatedAt`. In `internal/config/config.go`, create a `Config` struct and a `LoadConfig` function that reads environment variables from `.env.dev` (e.g., using a library like `godotenv` and `os.Getenv`) to populate the struct. The `main.go` file should call `LoadConfig` on startup.",
        "testStrategy": "Write unit tests for the `LoadConfig` function to ensure it correctly reads and parses environment variables. For domain models, ensure the project compiles successfully after defining the structs. No runtime tests are needed for the models themselves.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement DynamoDB Repository Layer",
        "description": "Define the repository interface and implement it for DynamoDB, including table creation logic and connection to LocalStack.",
        "details": "In `internal/repository/repository.go`, define a `DatabaseRepo` interface with methods for user and post operations (e.g., `CreateUser`, `GetUserByEmail`, `CreatePost`, `GetPostByID`, `GetPostsByUser`, etc.). In `internal/repository/dynamodb/dbrepo.go`, create a `DynamoDBRepo` struct that holds the DynamoDB client. Implement the `DatabaseRepo` interface. The implementation will use the AWS SDK for Go v2. The functions will construct `PutItem`, `GetItem`, `Query`, and `Scan` inputs based on the single-table design schema (e.g., for `CreateUser`, create two items: one with PK `USER#<UserID>` and SK `METADATA#<UserID>`, and for `CreatePost`, create items for the post itself, the user-post link, and the category-post link). Add a utility function `CreateTableIfNotExists` that is called on application startup to create the `WavyBlog` table in LocalStack with the specified PK and SK.",
        "testStrategy": "Write integration tests for the repository implementation. The tests should run against the LocalStack container. Each function in the repository (e.g., `CreateUser`, `GetPostByID`) should have a corresponding test that writes data to DynamoDB and then reads it back to verify correctness. Use the AWS CLI to manually inspect the `WavyBlog` table in LocalStack to confirm the single-table design patterns are being written correctly.",
        "priority": "high",
        "dependencies": [
          1,
          3
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement API Router and User Management Endpoints",
        "description": "Set up the Gin router and implement the HTTP handlers for all User Management API endpoints.",
        "details": "In `internal/api/router.go`, create a `SetupRouter` function that initializes a new Gin engine. It should take the `DatabaseRepo` as a dependency. Create a `/api` route group. In `internal/api/handlers/users.go`, create handlers for `POST /users/register`, `POST /users/login`, `GET /users`, and `GET /users/:id`. The `register` handler will hash the password (using `bcrypt`) before calling the repository. The `login` handler will verify credentials and generate a JWT token (using a library like `golang-jwt/jwt/v5`). The `main.go` file will initialize the repository, pass it to the router, and start the HTTP server.",
        "testStrategy": "Use an API client like Postman or Insomnia to test the endpoints. 1. Send a POST request to `/api/users/register` with user data and verify a 201 response. 2. Use the new credentials to POST to `/api/users/login` and verify a JWT is returned. 3. Attempt to access protected endpoints (e.g., `GET /users`) without and with the token to test authentication middleware. 4. Check the DynamoDB table via AWS CLI to confirm the user record was created correctly.",
        "priority": "medium",
        "dependencies": [
          2,
          4
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Post Management API Endpoints",
        "description": "Implement the HTTP handlers for all Post Management API endpoints, including CRUD operations.",
        "details": "In `internal/api/handlers/posts.go`, create handlers for `POST /posts`, `GET /posts`, `GET /posts/:id`, `PUT /posts/:id`, and `DELETE /posts/:id`. These handlers will receive the request, validate the input (and JWT for protected routes), call the appropriate methods on the `DatabaseRepo` interface, and return the response. The `POST /posts` handler will create multiple items in DynamoDB as per the single-table design (Post, PostByUser, PostByCategory). The `GET /posts` handler should support pagination using query parameters and perform a Scan or Query operation. The router in `router.go` should be updated to map these handlers to their respective routes.",
        "testStrategy": "Using an API client: 1. Register and log in a user to get a JWT. 2. Use the token to send a POST request to `/api/posts` to create a new post. 3. Send a GET request to `/api/posts` to verify the new post is in the list. 4. Send a GET request to `/api/posts/:id` to fetch the specific post. 5. Send PUT and DELETE requests to test update and delete functionality. Verify changes in the DynamoDB table.",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Category Endpoint and Finalize API",
        "description": "Implement the final API endpoint for retrieving unique post categories and perform final integration checks.",
        "details": "In `internal/repository/dynamodb/dbrepo.go`, add a `GetUniqueCategories` method. This method will perform a DynamoDB query targeting items with a PK prefix of `CATEGORY#`. It will need to process the results to return a list of unique category names. In `internal/api/handlers/posts.go` (or a new `categories.go`), create a handler for `GET /categories`. This handler will call the new repository method and return the list of unique categories as a JSON array. Update the router in `router.go` to include this new endpoint. This task also includes a final review of all code, adding logging middleware, and ensuring consistent error handling across all endpoints.",
        "testStrategy": "1. Create several posts with a mix of new and existing categories using the `/api/posts` endpoint. 2. Send a GET request to `/api/categories`. 3. Verify that the response is a JSON array of strings, containing each unique category name exactly once. 4. Manually query the DynamoDB table for `PK` starting with `CATEGORY#` to cross-reference the results and ensure correctness.",
        "priority": "low",
        "dependencies": [
          6
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement JWT Authentication and Middleware",
        "description": "Implement JWT generation for the login handler and create a middleware to protect post creation, update, and deletion endpoints, securing write operations for the application.",
        "details": "In `internal/api/handlers/users.go`, update the `LoginUser` handler. After successfully validating credentials, it should generate a signed JWT using a library like `github.com/golang-jwt/jwt/v5`. The JWT claims must include the `UserID` and an expiration time. The JWT secret key should be loaded from the application's configuration. Create a new package `internal/api/middleware` with an `AuthMiddleware()` function. This middleware will extract the token from the 'Authorization: Bearer <token>' header, validate its signature and expiration, and extract the `UserID` from its claims. The extracted `UserID` should be set in the Gin context for use by subsequent handlers. If the token is missing or invalid, the middleware must abort the request with a 401 Unauthorized status. In `internal/api/router.go`, apply this new middleware to a route group that includes the protected routes: `POST /posts`, `PUT /posts/:id`, and `DELETE /posts/:id`.",
        "testStrategy": "1. Attempt to access a protected endpoint, e.g., `POST /api/posts`, without an Authorization header. Verify the response is `401 Unauthorized`. 2. Attempt to access the same endpoint with an invalid or expired JWT. Verify the response is `401 Unauthorized`. 3. Send a `POST` request to `/api/users/login` with valid credentials. Verify the response is `200 OK` and contains a JWT in the response body. 4. Using the token from the successful login, send a `POST` request to `/api/posts` with the header `Authorization: Bearer <jwt>`. Verify the request succeeds with a `201 Created` status. 5. Confirm that public routes like `GET /api/posts` remain accessible without any token.",
        "status": "done",
        "dependencies": [
          5,
          6
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Update and Delete User API Endpoints",
        "description": "Implement the API endpoints for updating and deleting user profiles. This includes creating the repository methods and HTTP handlers, ensuring the endpoints are protected by JWT authentication.",
        "details": "This task involves extending the user management functionality. First, in `internal/repository/repository.go`, add `UpdateUser(ctx context.Context, user models.User) error` and `DeleteUser(ctx context.Context, userID string) error` to the `DatabaseRepo` interface. Then, implement these methods in `internal/repository/dynamodb/dbrepo.go`. The `UpdateUser` method should use a DynamoDB `UpdateItem` operation to modify user attributes, disallowing changes to `UserID` and `Email`, and automatically updating the `UpdatedAt` timestamp. The `DeleteUser` method will use `DeleteItem` to remove the user's primary record. In `internal/api/handlers/users.go`, create `UpdateUser` and `DeleteUser` handlers. These handlers must extract the user ID from the JWT claims (added by the auth middleware) and compare it against the user ID from the URL path (`:id`) to ensure a user can only modify or delete their own account. Finally, register the new `PUT /users/:id` and `DELETE /users/:id` routes in `internal/api/router.go` within the route group protected by the `AuthMiddleware`.",
        "testStrategy": "1. Register two users, User A and User B, and log them in to obtain their respective JWTs. 2. Using User A's JWT, send a `PUT` request to `/api/users/{user_a_id}` with updated data (e.g., new username). Verify a `200 OK` response with the updated user object. 3. Using User B's JWT, attempt to send a `PUT` request to `/api/users/{user_a_id}`. Verify the response is `403 Forbidden`. 4. Attempt to send a `PUT` request to `/api/users/{user_a_id}` without any JWT. Verify the response is `401 Unauthorized`. 5. Using User A's JWT, send a `DELETE` request to `/api/users/{user_a_id}`. Verify a `204 No Content` response. 6. Attempt to log in as User A and verify it fails, confirming deletion.",
        "status": "done",
        "dependencies": [
          4,
          5,
          8
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Update and Delete Post API Endpoints",
        "description": "Implement the API endpoints for updating and deleting posts. This includes creating the repository methods and HTTP handlers, ensuring the endpoints are protected by JWT authentication.",
        "details": "First, extend the `DatabaseRepo` interface in `internal/repository/repository.go` with `UpdatePost(ctx context.Context, post models.Post) error` and `DeletePost(ctx context.Context, postID, authorID string) error`. Implement these methods in `internal/repository/dynamodb/dbrepo.go`. The `UpdatePost` method should use a DynamoDB `UpdateItem` operation to modify the main post item (PK: `POST#{postID}`). It must also update the denormalized data in the `PostByUser` item (PK: `USER#{authorID}`, SK: `POST#{postID}`). The `DeletePost` method must perform a transactional write (`TransactWriteItems`) to atomically delete the three related items: the main `Post` item, the `PostByUser` item, and the `PostByCategory` item. In `internal/api/handlers/posts.go`, create `UpdatePost` and `DeletePost` handlers. These handlers must extract the `UserID` from the JWT context, fetch the post by its ID to verify the `AuthorID` matches the user's ID, and then call the appropriate repository method. Finally, register the new `PUT /api/posts/:id` and `DELETE /api/posts/:id` routes in `router.go` within the route group protected by the `AuthMiddleware`.",
        "testStrategy": "1. Register and log in two separate users (User A and User B) to obtain their JWTs. 2. Using User A's JWT, create a new post. 3. Using User A's JWT, send a `PUT` request to `/api/posts/{post_id}` with updated title and content. Verify a `200 OK` response and that a subsequent `GET` request for the post returns the updated data. 4. Using User B's JWT, attempt to send a `PUT` request to the same post ID. Verify the response is `403 Forbidden`. 5. Using User B's JWT, attempt to send a `DELETE` request for the post. Verify the response is `403 Forbidden`. 6. Using User A's JWT, send a `DELETE` request for the post. Verify a `204 No Content` response. 7. Attempt to `GET` the post by its ID and verify a `404 Not Found` response.",
        "status": "done",
        "dependencies": [
          6,
          8
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Create Bruno Project for API Testing",
        "description": "Create a Bruno project to automate API testing. This includes setting up collections and requests for user registration, login, and post creation, with scripting to handle JWT authentication.",
        "details": "In the project root, create a new directory named `bruno-tests`. Inside this directory, initialize a new Bruno collection. Create a 'local' environment to store variables, starting with `baseUrl` set to `http://localhost:8080/api`. Configure three requests within the collection:\n1. **Register User**: A `POST` request to `{{baseUrl}}/users/register` with a JSON body containing `username`, `email`, and `password`.\n2. **Login User**: A `POST` request to `{{baseUrl}}/users/login` with the same `email` and `password`. In the 'Tests' tab of this request, add a script to parse the response body, extract the `access_token`, and set it as a collection variable named `authToken` using `bru.setVar('authToken', res.body.access_token);`.\n3. **Create Post**: A `POST` request to `{{baseUrl}}/posts`. In the 'Auth' tab, select 'Bearer Token' and use the `{{authToken}}` variable. The request body should be JSON with `title`, `content`, and `category` fields.",
        "testStrategy": "1. Run the 'Register User' request and verify a `201 Created` response.\n2. Run the 'Login User' request. Verify a `200 OK` response and inspect the Bruno collection variables to confirm that `authToken` has been set with a valid JWT.\n3. Run the 'Create Post' request. Verify it succeeds with a `201 Created` response, which confirms the bearer token was correctly extracted and used for authentication.\n4. Ensure the entire `bruno-tests` directory and its contents are committed to the repository.",
        "status": "done",
        "dependencies": [
          5,
          6,
          8
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Fix 404 Error in Bruno Login Request by Correcting Port",
        "description": "Correct the port number in the Bruno 'local' environment configuration to resolve the 404 Not Found error when executing the login API request. The port must match the one exposed by the backend service in the Docker environment.",
        "details": "The 'Login User' request in the Bruno collection is failing with a 404 error because the `baseUrl` variable in the 'local' environment points to the wrong port. Locate the Bruno environment configuration file (likely within the `bruno-tests` directory). Inspect the `docker-compose.dev.yml` file to find the host port mapped to the `api-backend` service's container port (e.g., '8090:8080'). Update the `baseUrl` variable in the Bruno 'local' environment to use the correct host port. For example, change `http://localhost:8080/api` to `http://localhost:8090/api` if the host port is 8090.",
        "testStrategy": "1. Ensure the backend application is running via `docker compose -f docker-compose.dev.yml up`. 2. Open the API collection in Bruno. 3. Run the 'Register User' request to ensure a test user exists. 4. Run the 'Login User' request using the same credentials. 5. Verify that the request now succeeds with a `200 OK` status code, resolving the previous `404 Not Found` error. 6. Check the collection variables to confirm that the `authToken` has been successfully extracted and stored from the response.",
        "status": "done",
        "dependencies": [
          1,
          5,
          11
        ],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-11T12:06:24.226Z",
      "updated": "2025-07-11T12:06:24.226Z",
      "description": "Tasks for connecting the frontend to the backend API with SSR."
    }
  }
}